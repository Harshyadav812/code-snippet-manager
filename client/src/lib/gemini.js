const GEMINI_API_KEY = process.env.NEXT_PUBLIC_GEMINI_API_KEY
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent'

const callGeminiAPI = async (prompt) => {
  try {
    if (!GEMINI_API_KEY) {
      throw new Error('Gemini API key is not configured')
    }

    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 1024,
        },
        safetySettings: [
          {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: "BLOCK_MEDIUM_AND_ABOVE"
          },
          {
            category: "HARM_CATEGORY_HATE_SPEECH",
            threshold: "BLOCK_MEDIUM_AND_ABOVE"
          },
          {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: "BLOCK_MEDIUM_AND_ABOVE"
          },
          {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: "BLOCK_MEDIUM_AND_ABOVE"
          }
        ]
      })
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}))
      console.error('Gemini API Response:', {
        status: response.status,
        statusText: response.statusText,
        error: errorData
      })
      throw new Error(`Gemini API error: ${response.status} ${response.statusText}`)
    }

    const data = await response.json()

    if (!data.candidates || data.candidates.length === 0) {
      console.error('No candidates in response:', data)
      throw new Error('No response generated by Gemini')
    }

    const content = data.candidates[0]?.content?.parts[0]?.text
    if (!content) {
      console.error('No content in candidate:', data.candidates[0])
      throw new Error('Empty response from Gemini')
    }

    return content
  } catch (error) {
    console.error('Gemini API Error:', error)

    // More specific error messages
    if (error.message.includes('API key')) {
      throw new Error('AI service configuration error. Please check API key.')
    } else if (error.message.includes('429')) {
      throw new Error('Too many requests. Please wait a moment and try again.')
    } else if (error.message.includes('403')) {
      throw new Error('API access denied. Please check your API key permissions.')
    } else if (error.message.includes('NetworkError') || error.name === 'TypeError') {
      throw new Error('Network error. Please check your internet connection.')
    }

    throw new Error(`Failed to get AI response: ${error.message}`)
  }
}

export const generateTags = async (code, title = '', description = '') => {
  const prompt = `
Analyze this code snippet and suggest 3-5 relevant tags that would help developers find it.

Title: ${title}
Description: ${description}
Code:
\`\`\`
${code}
\`\`\`

Guidelines:
- Include the programming language
- Include framework/library names if used
- Include concept/pattern names (e.g., "hooks", "async", "recursion")
- Include use case tags (e.g., "authentication", "api", "database")
- Keep tags lowercase, use hyphens for spaces
- Maximum 5 tags

Respond with ONLY a JSON array of strings, no explanation:
["tag1", "tag2", "tag3"]
`

  try {
    const response = await callGeminiAPI(prompt)
    const cleanResponse = response.replace(/```json\n?|\n?```/g, '').trim()
    const tags = JSON.parse(cleanResponse)

    if (Array.isArray(tags) && tags.length > 0) {
      return tags.slice(0, 5) // Limit to 5 tags
    }

    return []
  } catch (error) {
    console.error('Error generating tags:', error)
    // Return some default tags based on common patterns
    const defaultTags = []
    if (code.includes('function') || code.includes('=>')) defaultTags.push('javascript')
    if (code.includes('import') || code.includes('export')) defaultTags.push('es6')
    if (code.includes('useState') || code.includes('useEffect')) defaultTags.push('react', 'hooks')
    if (code.includes('async') || code.includes('await')) defaultTags.push('async')

    return defaultTags.slice(0, 3)
  }
}

export const analyzeCode = async (code, language = '') => {
  const prompt = `
Analyze this ${language} code snippet for:
1. Potential bugs or errors
2. Performance improvements
3. Best practice suggestions
4. Security concerns (if any)

Code:
\`\`\`${language}
${code}
\`\`\`

Provide your analysis in this JSON format:
{
  "issues": [
    {
      "type": "error|warning|suggestion",
      "message": "Description of the issue",
      "line": "approximate line number or 'general'",
      "severity": "high|medium|low"
    }
  ],
  "improvements": [
    "Specific improvement suggestion 1",
    "Specific improvement suggestion 2"
  ],
  "overall_rating": "excellent|good|fair|needs_work",
  "summary": "Brief overall assessment"
}

Be constructive and helpful. If the code is good, say so!
`

  try {
    const response = await callGeminiAPI(prompt)
    const cleanResponse = response.replace(/```json\n?|\n?```/g, '').trim()
    const analysis = JSON.parse(cleanResponse)

    return {
      issues: analysis.issues || [],
      improvements: analysis.improvements || [],
      overall_rating: analysis.overall_rating || 'fair',
      summary: analysis.summary || 'Code analysis completed'
    }
  } catch (error) {
    console.error('Error analyzing code:', error)
    return {
      issues: [],
      improvements: ['Consider adding error handling', 'Add comments for clarity'],
      overall_rating: 'fair',
      summary: 'Unable to analyze code at this time, but it appears functional'
    }
  }
}

export const suggestCodeImprovement = async (code, language = '') => {
  const prompt = `
Improve this ${language} code snippet by:
1. Fixing any bugs or errors
2. Adding better error handling
3. Improving performance where possible
4. Following best practices
5. Adding helpful comments

Original code:
\`\`\`${language}
${code}
\`\`\`

Respond with:
{
  "improved_code": "the improved code with comments",
  "changes_made": [
    "List of specific improvements made"
  ],
  "explanation": "Brief explanation of why these changes help"
}

Keep the core functionality the same, just make it better!
`

  try {
    const response = await callGeminiAPI(prompt)
    const cleanResponse = response.replace(/```json\n?|\n?```/g, '').trim()
    const improvement = JSON.parse(cleanResponse)

    return {
      improved_code: improvement.improved_code || code,
      changes_made: improvement.changes_made || [],
      explanation: improvement.explanation || 'No improvements suggested'
    }
  } catch (error) {
    console.error('Error improving code:', error)
    return {
      improved_code: code,
      changes_made: ['Unable to process improvements at this time'],
      explanation: 'AI service temporarily unavailable. Your code appears functional as-is.'
    }
  }
}

export const detectLanguage = async (code) => {
  const prompt = `
Identify the programming language of this code snippet:

\`\`\`
${code}
\`\`\`

Respond with ONLY the language name in lowercase (e.g., "javascript", "python", "java", "css", "html").
If unsure, respond with "unknown".
`

  try {
    const response = await callGeminiAPI(prompt)
    return response.trim().toLowerCase()
  } catch (error) {
    console.error('Error detecting language:', error)

    // Simple fallback language detection
    if (code.includes('function') || code.includes('=>') || code.includes('const') || code.includes('let')) {
      return 'javascript'
    } else if (code.includes('def ') || code.includes('import ')) {
      return 'python'
    } else if (code.includes('public class') || code.includes('System.out')) {
      return 'java'
    } else if (code.includes('<') && code.includes('>')) {
      return 'html'
    } else if (code.includes('{') && code.includes('}') && code.includes(':')) {
      return 'css'
    }

    return 'unknown'
  }
}

export const generateTitleAndDescription = async (code) => {
  const prompt = `
Analyze this code snippet and suggest:
1. A concise, descriptive title (max 50 characters)
2. A helpful description (max 150 characters)

Code:
\`\`\`
${code}
\`\`\`

Respond with:
{
  "title": "Suggested title",
  "description": "What this code does and when to use it"
}
`

  try {
    const response = await callGeminiAPI(prompt)
    const cleanResponse = response.replace(/```json\n?|\n?```/g, '').trim()
    const suggestion = JSON.parse(cleanResponse)

    return {
      title: suggestion.title || 'Code Snippet',
      description: suggestion.description || 'Useful code snippet'
    }
  } catch (error) {
    console.error('Error generating title/description:', error)

    // Simple fallback based on code content
    let title = 'Code Snippet'
    let description = 'Useful code snippet'

    if (code.includes('function')) {
      title = 'JavaScript Function'
      description = 'Custom JavaScript function for specific functionality'
    } else if (code.includes('useState') || code.includes('useEffect')) {
      title = 'React Component'
      description = 'React component with hooks for state management'
    } else if (code.includes('async') || code.includes('await')) {
      title = 'Async Function'
      description = 'Asynchronous function for handling promises'
    }

    return { title, description }
  }
}

let requestCount = 0
let lastResetTime = Date.now()

export const checkRateLimit = () => {
  const now = Date.now()
  const oneMinute = 60 * 1000

  if (now - lastResetTime > oneMinute) {
    requestCount = 0
    lastResetTime = now
  }

  if (requestCount >= 15) {
    throw new Error('Rate limit reached. Please wait a moment before trying again.')
  }

  requestCount++
  return true
}